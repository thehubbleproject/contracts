{
  "language": "Solidity",
  "sources": {
    "contracts/Deployer.sol": {
      "content": "pragma solidity ^0.5.15;\nimport {ParamManager} from \"./libs/ParamManager.sol\";\nimport {NameRegistry as Registry} from \"./NameRegistry.sol\";\nimport {Tree as MerkleTree} from \"./Tree.sol\";\nimport {IncrementalTree} from \"./IncrementalTree.sol\";\nimport {DepositManager} from \"./DepositManager.sol\";\nimport {TestToken} from \"./TestToken.sol\";\nimport {Rollup} from \"./Rollup.sol\";\nimport {TokenRegistry} from \"./TokenRegistry.sol\";\nimport {Logger} from \"./Logger.sol\";\nimport {MerkleTreeUtils as MTUtils} from \"./MerkleTreeUtils.sol\";\n\n\n// Deployer is supposed to deploy new set of contracts while setting up all the utilities\n// libraries and other auxiallry contracts like registry\ncontract Deployer {\n    constructor(address nameregistry) public {\n        deployContracts(nameregistry);\n    }\n\n    function deployContracts(address nameRegistryAddr)\n        public\n        returns (address)\n    {\n        Registry registry = Registry(nameRegistryAddr);\n        address mtUtils = address(new MTUtils());\n        require(\n            registry.registerName(ParamManager.MERKLE_UTILS(), mtUtils),\n            \"Could not register merkle utils tree\"\n        );\n\n        address logger = address(new Logger());\n        require(\n            registry.registerName(ParamManager.LOGGER(), logger),\n            \"Cannot register logger\"\n        );\n\n        address tokenRegistry = address(new TokenRegistry(nameRegistryAddr));\n        require(\n            registry.registerName(ParamManager.TOKEN_REGISTRY(), tokenRegistry),\n            \"Cannot register token registry\"\n        );\n\n        return nameRegistryAddr;\n        // address balancesTree = address(new MerkleTree(nameRegistryAddr));\n        // require(\n        //     registry.registerName(ParamManager.BALANCES_TREE(), balancesTree),\n        //     \"Could not register balances tree\"\n        // );\n        // deploy accounts tree\n        // address accountsTree = address(new IncrementalTree(nameRegistryAddr));\n        // require(\n        //     registry.registerName(ParamManager.ACCOUNTS_TREE(), accountsTree),\n        //     \"Could not register accounts tree\"\n        // );\n\n        // deposit manager\n        // address depositManager = address(new DepositManager(nameRegistryAddr));\n        // require(\n        //     registry.registerName(\n        //         ParamManager.DEPOSIT_MANAGER(),\n        //         depositManager\n        //     ),\n        //     \"Cannot register deposit manager\"\n        // );\n\n        // // deploy core rollup contract\n        // address rollup = address(new Rollup(nameRegistryAddr));\n        // require(\n        //     registry.registerName(ParamManager.ROLLUP_CORE(), rollup),\n        //     \"Cannot register core rollup\"\n        // );\n    }\n}\n"
    },
    "contracts/libs/ParamManager.sol": {
      "content": "pragma solidity ^0.5.15;\n\n\nlibrary ParamManager {\n    function DEPOSIT_MANAGER() public pure returns (bytes32) {\n        return keccak256(\"deposit_manager\");\n    }\n\n    function WITHDRAW_MANAGER() public pure returns (bytes32) {\n        return keccak256(\"withdraw_manager\");\n    }\n\n    function TEST_TOKEN() public pure returns (bytes32) {\n        return keccak256(\"test_token\");\n    }\n\n    function ROLLUP_CORE() public pure returns (bytes32) {\n        return keccak256(\"rollup_core\");\n    }\n\n    function ACCOUNTS_TREE() public pure returns (bytes32) {\n        return keccak256(\"accounts_tree\");\n    }\n\n    function BALANCES_TREE() public pure returns (bytes32) {\n        return keccak256(\"balances_tree\");\n    }\n\n    function LOGGER() public pure returns (bytes32) {\n        return keccak256(\"logger\");\n    }\n\n    function MERKLE_UTILS() public pure returns (bytes32) {\n        return keccak256(\"merkle_lib\");\n    }\n\n    function PARAM_MANAGER() public pure returns (bytes32) {\n        return keccak256(\"param_manager\");\n    }\n\n    function TOKEN_REGISTRY() public pure returns (bytes32) {\n        return keccak256(\"token_registry\");\n    }\n\n    uint8 public constant _MAX_DEPTH = 4;\n\n    function MAX_DEPTH() public pure returns (uint8) {\n        return _MAX_DEPTH;\n    }\n\n    uint8 public constant _MAX_DEPOSIT_SUBTREE = 2;\n\n    function MAX_DEPOSIT_SUBTREE() public pure returns (uint8) {\n        return _MAX_DEPOSIT_SUBTREE;\n    }\n\n    bytes32 public constant _CHAIN_ID = keccak256(\"opru-123\");\n\n    function CHAIN_ID() public pure returns (bytes32) {\n        return _CHAIN_ID;\n    }\n\n    // finalisation time is the number of blocks required by a batch to finalise\n    // Delay period = 7 days. Block time = 15 seconds\n    uint256 public constant _TIME_TO_FINALISE = 7 days;\n\n    function TIME_TO_FINALISE() public pure returns (uint256) {\n        return _TIME_TO_FINALISE;\n    }\n\n    // min gas required before rollback pauses\n    uint256 public constant _MIN_GAS_LIMIT_LEFT = 100000;\n\n    function MIN_GAS_LIMIT_LEFT() public pure returns (uint256) {\n        return _MIN_GAS_LIMIT_LEFT;\n    }\n\n    uint256 public constant _MAX_TXS_PER_BATCH = 10;\n\n    function MAX_TXS_PER_BATCH() public pure returns (uint256) {\n        return _MAX_TXS_PER_BATCH;\n    }\n\n    uint256 public constant _STAKE_AMOUNT = 32;\n\n    function STAKE_AMOUNT() public pure returns (uint256) {\n        return _STAKE_AMOUNT;\n    }\n\n    address payable constant _BURN_ADDRESS = 0x0000000000000000000000000000000000000000;\n\n    function BURN_ADDRESS() public pure returns (address payable) {\n        return _BURN_ADDRESS;\n    }\n\n    bytes32 public constant _ZERO_BYTES32 = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    function ZERO_BYTES32() public pure returns (bytes32) {\n        return _ZERO_BYTES32;\n    }\n}\n"
    },
    "contracts/NameRegistry.sol": {
      "content": "pragma solidity ^0.5.15;\n\n\ncontract NameRegistry {\n    struct ContractDetails {\n        // registered contract address\n        address contractAddress;\n    }\n    event RegisteredNewContract(bytes32 name, address contractAddr);\n    mapping(bytes32 => ContractDetails) registry;\n\n    function registerName(bytes32 name, address addr) external returns (bool) {\n        ContractDetails memory info = registry[name];\n        // create info if it doesn't exist in the registry\n        if (info.contractAddress == address(0)) {\n            info.contractAddress = addr;\n            registry[name] = info;\n            // added to registry\n            return true;\n        } else {\n            // already was registered\n            return false;\n        }\n    }\n\n    function getContractDetails(bytes32 name) external view returns (address) {\n        return (registry[name].contractAddress);\n    }\n\n    function updateContractDetails(bytes32 name, address addr) external {\n        // TODO not sure if we should do this\n        // If we do we need a plan on how to remove this\n    }\n}\n"
    },
    "contracts/Tree.sol": {
      "content": "pragma solidity ^0.5.15;\nimport {MerkleTreeUtils as MTUtils} from \"./MerkleTreeUtils.sol\";\nimport {NameRegistry as Registry} from \"./NameRegistry.sol\";\nimport {ParamManager} from \"./libs/ParamManager.sol\";\n\n\n/*\n * Merkle Tree Utilities for Rollup\n */\ncontract Tree {\n    Registry public nameRegistry;\n    MTUtils merkleUtils; /* Structs */\n    // A partial merkle tree which can be updated with new nodes, recomputing the root\n    struct MerkleTree {\n        // The root\n        bytes32 root;\n        uint256 height;\n        mapping(bytes32 => bytes32) nodes;\n    }\n\n    constructor(address _registryAddr) public {\n        nameRegistry = Registry(_registryAddr);\n        merkleUtils = MTUtils(\n            nameRegistry.getContractDetails(ParamManager.MERKLE_UTILS())\n        );\n        setMerkleRootAndHeight(\n            merkleUtils.getZeroRoot(),\n            merkleUtils.getMaxTreeDepth()\n        );\n    }\n\n    // A tree which is used in `update()` and `store()`\n    MerkleTree public tree;\n\n    /**\n     * @notice Update the stored tree / root with a particular dataBlock at some path (no siblings needed)\n     * @param _dataBlock The data block we're storing/verifying\n     * @param _path The path from the leaf to the root / the index of the leaf.\n     */\n    function update(bytes memory _dataBlock, uint256 _path) public {\n        bytes32[] memory siblings = getSiblings(_path);\n        store(_dataBlock, _path, siblings);\n    }\n\n    /**\n     * @notice Update the stored tree / root with a particular leaf hash at some path (no siblings needed)\n     * @param _leaf The leaf we're storing/verifying\n     *   @param _path The path from the leaf to the root / the index of the leaf.\n     */\n    function updateLeaf(bytes32 _leaf, uint256 _path) public {\n        bytes32[] memory siblings = getSiblings(_path);\n        storeLeaf(_leaf, _path, siblings);\n    }\n\n    /**\n     * @notice Store a particular merkle proof & verify that the root did not change.\n     * @param _dataBlock The data block we're storing/verifying\n     * @param _path The path from the leaf to the root / the index of the leaf.\n     * @param _siblings The sibling nodes along the way.\n     */\n    function verifyAndStore(\n        bytes memory _dataBlock,\n        uint256 _path,\n        bytes32[] memory _siblings\n    ) public {\n        bytes32 oldRoot = tree.root;\n        store(_dataBlock, _path, _siblings);\n        require(tree.root == oldRoot, \"Failed same root verification check!\");\n    }\n\n    /**\n     * @notice Store a particular dataBlock & its intermediate nodes in the tree\n     * @param _dataBlock The data block we're storing.\n     * @param _path The path from the leaf to the root / the index of the leaf.\n     * @param _siblings The sibling nodes along the way.\n     */\n    function store(\n        bytes memory _dataBlock,\n        uint256 _path,\n        bytes32[] memory _siblings\n    ) public {\n        // Compute the leaf node & store the leaf\n        bytes32 leaf = keccak256(_dataBlock);\n        storeLeaf(leaf, _path, _siblings);\n    }\n\n    /**\n     * @notice Store a particular leaf hash & its intermediate nodes in the tree\n     * @param _leaf The leaf we're storing.\n     * @param _path The path from the leaf to the root / the index of the leaf.\n     * @param _siblings The sibling nodes along the way.\n     */\n    function storeLeaf(bytes32 _leaf, uint256 _path, bytes32[] memory _siblings)\n        public\n    {\n        // First compute the leaf node\n        bytes32 computedNode = _leaf;\n        for (uint256 i = 0; i < _siblings.length; i++) {\n            bytes32 parent;\n            bytes32 sibling = _siblings[i];\n            uint8 isComputedRightSibling = merkleUtils.getNthBitFromRight(\n                _path,\n                i\n            );\n            if (isComputedRightSibling == 0) {\n                parent = merkleUtils.getParent(computedNode, sibling);\n                // Store the node!\n                storeNode(parent, computedNode, sibling);\n            } else {\n                parent = merkleUtils.getParent(sibling, computedNode);\n                // Store the node!\n                storeNode(parent, sibling, computedNode);\n            }\n            computedNode = parent;\n        }\n        // Store the new root\n        tree.root = computedNode;\n    }\n\n    /**\n     * @notice Get siblings for a leaf at a particular index of the tree.\n     *         This is used for updates which don't include sibling nodes.\n     * @param _path The path from the leaf to the root / the index of the leaf.\n     * @return The sibling nodes along the way.\n     */\n    function getSiblings(uint256 _path) public returns (bytes32[] memory) {\n        bytes32[] memory siblings = new bytes32[](tree.height);\n        bytes32 computedNode = tree.root;\n        for (uint256 i = tree.height; i > 0; i--) {\n            uint256 siblingIndex = i - 1;\n            (bytes32 leftChild, bytes32 rightChild) = getChildren(computedNode);\n            if (merkleUtils.getNthBitFromRight(_path, siblingIndex) == 0) {\n                computedNode = leftChild;\n                siblings[siblingIndex] = rightChild;\n            } else {\n                computedNode = rightChild;\n                siblings[siblingIndex] = leftChild;\n            }\n        }\n        // Now store everything\n        return siblings;\n    }\n\n    /*********************\n     * Utility Functions *\n     ********************/\n    /**\n     * @notice Get our stored tree's root\n     * @return The merkle root of the tree\n     */\n    function getRoot() public view returns (bytes32) {\n        return tree.root;\n    }\n\n    /**\n     * @notice Set the tree root and height of the stored tree\n     * @param _root The merkle root of the tree\n     * @param _height The height of the tree\n     */\n    function setMerkleRootAndHeight(bytes32 _root, uint256 _height) public {\n        tree.root = _root;\n        tree.height = _height;\n    }\n\n    /**\n     * @notice Store node in the (in-storage) merkle tree\n     * @param _parent The parent node\n     * @param _leftChild The left child of the parent in the tree\n     * @param _rightChild The right child of the parent in the tree\n     */\n    function storeNode(bytes32 _parent, bytes32 _leftChild, bytes32 _rightChild)\n        public\n    {\n        tree.nodes[merkleUtils.getLeftSiblingKey(_parent)] = _leftChild;\n        tree.nodes[merkleUtils.getRightSiblingKey(_parent)] = _rightChild;\n    }\n\n    /**\n     * @notice Get the children of some parent in the tree\n     * @param _parent The parent node\n     * @return (rightChild, leftChild) -- the two children of the parent\n     */\n    function getChildren(bytes32 _parent)\n        public\n        view\n        returns (bytes32, bytes32)\n    {\n        return (\n            tree.nodes[merkleUtils.getLeftSiblingKey(_parent)],\n            tree.nodes[merkleUtils.getRightSiblingKey(_parent)]\n        );\n    }\n}\n"
    },
    "contracts/MerkleTreeUtils.sol": {
      "content": "pragma solidity ^0.5.15;\npragma experimental ABIEncoderV2;\nimport {ParamManager} from \"./libs/ParamManager.sol\";\n\n\ncontract MerkleTreeUtils {\n    // The default hashes\n    // TODO remove 160 and use max depth from parammanager\n    bytes32[] public defaultHashes;\n    uint256 public MAX_DEPTH;\n    bytes32 public ZERO_BYTES32 = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /**\n     * @notice Initialize a new MerkleTree contract, computing the default hashes for the merkle tree (MT)\n     */\n    constructor() public {\n        MAX_DEPTH = ParamManager.MAX_DEPTH();\n        defaultHashes = new bytes32[](MAX_DEPTH);\n        // Calculate & set the default hashes\n        setDefaultHashes(MAX_DEPTH);\n    }\n\n    /* Methods */\n\n    /**\n     * @notice Set default hashes\n     */\n    function setDefaultHashes(uint256 depth) internal {\n        // Set the initial default hash.\n        defaultHashes[0] = keccak256(abi.encode(0));\n        for (uint256 i = 1; i < depth; i++) {\n            defaultHashes[i] = keccak256(\n                abi.encode(defaultHashes[i - 1], defaultHashes[i - 1])\n            );\n        }\n    }\n\n    function getZeroRoot() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    defaultHashes[MAX_DEPTH - 1],\n                    defaultHashes[MAX_DEPTH - 1]\n                )\n            );\n    }\n\n    function getMaxTreeDepth() public view returns (uint256) {\n        return MAX_DEPTH;\n    }\n\n    function getRoot(uint256 index) public view returns (bytes32) {\n        return defaultHashes[index];\n    }\n\n    function keecakHash(bytes memory data) public pure returns (bytes32) {\n        return keccak256(data);\n    }\n\n    /**\n     * @notice Get the merkle root computed from some set of data blocks.\n     * @param _dataBlocks The data being used to generate the tree.\n     * @return the merkle tree root\n     * NOTE: This is a stateless operation\n     */\n    function getMerkleRoot(bytes[] calldata _dataBlocks)\n        external\n        returns (bytes32)\n    {\n        uint256 nextLevelLength = _dataBlocks.length;\n        uint256 currentLevel = 0;\n        bytes32[] memory nodes = new bytes32[](nextLevelLength + 1); // Add one in case we have an odd number of leaves\n        // Generate the leaves\n        for (uint256 i = 0; i < _dataBlocks.length; i++) {\n            nodes[i] = keccak256(_dataBlocks[i]);\n        }\n        if (_dataBlocks.length == 1) {\n            return nodes[0];\n        }\n        // Add a defaultNode if we've got an odd number of leaves\n        if (nextLevelLength % 2 == 1) {\n            nodes[nextLevelLength] = defaultHashes[currentLevel];\n            nextLevelLength += 1;\n        }\n\n        // Now generate each level\n        while (nextLevelLength > 1) {\n            currentLevel += 1;\n            // Calculate the nodes for the currentLevel\n            for (uint256 i = 0; i < nextLevelLength / 2; i++) {\n                nodes[i] = getParent(nodes[i * 2], nodes[i * 2 + 1]);\n            }\n            nextLevelLength = nextLevelLength / 2;\n            // Check if we will need to add an extra node\n            if (nextLevelLength % 2 == 1 && nextLevelLength != 1) {\n                nodes[nextLevelLength] = defaultHashes[currentLevel];\n                nextLevelLength += 1;\n            }\n        }\n        // Alright! We should be left with a single node! Return it...\n        return nodes[0];\n    }\n\n    /**\n     * @notice Calculate root from an inclusion proof.\n     * @param _dataBlock The data block we're calculating root for.\n     * @param _path The path from the leaf to the root.\n     * @param _siblings The sibling nodes along the way.\n     * @return The next level of the tree\n     * NOTE: This is a stateless operation\n     */\n    function computeInclusionProofRoot(\n        bytes memory _dataBlock,\n        uint256 _path,\n        bytes32[] memory _siblings\n    ) public pure returns (bytes32) {\n        // First compute the leaf node\n        bytes32 computedNode = keccak256(_dataBlock);\n\n        for (uint256 i = 0; i < _siblings.length; i++) {\n            bytes32 sibling = _siblings[i];\n            uint8 isComputedRightSibling = getNthBitFromRight(_path, i);\n            if (isComputedRightSibling == 0) {\n                computedNode = getParent(computedNode, sibling);\n            } else {\n                computedNode = getParent(sibling, computedNode);\n            }\n        }\n        // Check if the computed node (_root) is equal to the provided root\n        return computedNode;\n    }\n\n    /**\n     * @notice Calculate root from an inclusion proof.\n     * @param _leaf The data block we're calculating root for.\n     * @param _path The path from the leaf to the root.\n     * @param _siblings The sibling nodes along the way.\n     * @return The next level of the tree\n     * NOTE: This is a stateless operation\n     */\n    function computeInclusionProofRootWithLeaf(\n        bytes32 _leaf,\n        uint256 _path,\n        bytes32[] memory _siblings\n    ) public view returns (bytes32) {\n        // First compute the leaf node\n        bytes32 computedNode = _leaf;\n        for (uint256 i = 0; i < _siblings.length; i++) {\n            bytes32 sibling = _siblings[i];\n            uint8 isComputedRightSibling = getNthBitFromRight(_path, i);\n            if (isComputedRightSibling == 0) {\n                computedNode = getParent(computedNode, sibling);\n            } else {\n                computedNode = getParent(sibling, computedNode);\n            }\n        }\n        // Check if the computed node (_root) is equal to the provided root\n        return computedNode;\n    }\n\n    /**\n     * @notice Verify an inclusion proof.\n     * @param _root The root of the tree we are verifying inclusion for.\n     * @param _dataBlock The data block we're verifying inclusion for.\n     * @param _path The path from the leaf to the root.\n     * @param _siblings The sibling nodes along the way.\n     * @return The next level of the tree\n     * NOTE: This is a stateless operation\n     */\n    function verify(\n        bytes32 _root,\n        bytes memory _dataBlock,\n        uint256 _path,\n        bytes32[] memory _siblings\n    ) public view returns (bool) {\n        // First compute the leaf node\n        bytes32 calculatedRoot = computeInclusionProofRoot(\n            _dataBlock,\n            _path,\n            _siblings\n        );\n        return calculatedRoot == _root;\n    }\n\n    /**\n     * @notice Verify an inclusion proof.\n     * @param _root The root of the tree we are verifying inclusion for.\n     * @param _leaf The data block we're verifying inclusion for.\n     * @param _path The path from the leaf to the root.\n     * @param _siblings The sibling nodes along the way.\n     * @return The next level of the tree\n          * NOTE: This is a stateless operation\n\n     */\n    function verifyLeaf(\n        bytes32 _root,\n        bytes32 _leaf,\n        uint256 _path,\n        bytes32[] memory _siblings\n    ) public view returns (bool) {\n        bytes32 calculatedRoot = computeInclusionProofRootWithLeaf(\n            _leaf,\n            _path,\n            _siblings\n        );\n        return calculatedRoot == _root;\n    }\n\n    /**\n     * @notice Update a leaf using siblings and root\n     *         This is a stateless operation\n     * @param _leaf The leaf we're updating.\n     * @param _path The path from the leaf to the root / the index of the leaf.\n     * @param _siblings The sibling nodes along the way.\n     * @return Updated root\n     */\n    function updateLeafWithSiblings(\n        bytes32 _leaf,\n        uint256 _path,\n        bytes32[] memory _siblings\n    ) public pure returns (bytes32) {\n        bytes32 computedNode = _leaf;\n        for (uint256 i = 0; i < _siblings.length; i++) {\n            bytes32 parent;\n            bytes32 sibling = _siblings[i];\n            uint8 isComputedRightSibling = getNthBitFromRight(_path, i);\n            if (isComputedRightSibling == 0) {\n                parent = getParent(computedNode, sibling);\n            } else {\n                parent = getParent(sibling, computedNode);\n            }\n            computedNode = parent;\n        }\n        return computedNode;\n    }\n\n    /**\n     * @notice Get the parent of two children nodes in the tree\n     * @param _left The left child\n     * @param _right The right child\n     * @return The parent node\n     */\n    function getParent(bytes32 _left, bytes32 _right)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(_left, _right));\n    }\n\n    /**\n     * @notice get the n'th bit in a uint.\n     *         For instance, if exampleUint=binary(11), getNth(exampleUint, 0) == 1, getNth(2, 1) == 1\n     * @param _intVal The uint we are extracting a bit out of\n     * @param _index The index of the bit we want to extract\n     * @return The bit (1 or 0) in a uint8\n     */\n    function getNthBitFromRight(uint256 _intVal, uint256 _index)\n        public\n        pure\n        returns (uint8)\n    {\n        return uint8((_intVal >> _index) & 1);\n    }\n\n    /**\n     * @notice Get the right sibling key. Note that these keys overwrite the first bit of the hash\n               to signify if it is on the right side of the parent or on the left\n     * @param _parent The parent node\n     * @return the key for the left sibling (0 as the first bit)\n     */\n    function getLeftSiblingKey(bytes32 _parent) public pure returns (bytes32) {\n        return\n            _parent &\n            0x0111111111111111111111111111111111111111111111111111111111111111;\n    }\n\n    /**\n     * @notice Get the right sibling key. Note that these keys overwrite the first bit of the hash\n               to signify if it is on the right side of the parent or on the left\n     * @param _parent The parent node\n     * @return the key for the right sibling (1 as the first bit)\n     */\n    function getRightSiblingKey(bytes32 _parent) public pure returns (bytes32) {\n        return\n            _parent |\n            0x1000000000000000000000000000000000000000000000000000000000000000;\n    }\n\n    function pathToIndex(uint256 path, uint256 height)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 result = 0;\n        for (uint256 i = 0; i < height; i++) {\n            uint8 temp = getNthBitFromRight(path, i);\n            // UNSAFE FIX THIS\n            result = result + (temp * (2**i));\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/IncrementalTree.sol": {
      "content": "pragma solidity ^0.5.15;\n\nimport {MerkleTreeUtils as MTUtils} from \"./MerkleTreeUtils.sol\";\nimport {ParamManager} from \"./libs/ParamManager.sol\";\nimport {NameRegistry as Registry} from \"./NameRegistry.sol\";\n\n\ncontract IncrementalTree {\n    uint256 DEPTH = ParamManager.MAX_DEPTH();\n    Registry public nameRegistry;\n    MTUtils public merkleUtils;\n\n    MerkleTree public tree;\n    // Merkle Tree to store the whole tree\n    struct MerkleTree {\n        // Root of the tree\n        bytes32 root;\n        // current height of the tree\n        uint256 height;\n        // Allows you to compute the path to the element (but it's not the path to\n        // the elements). Caching these values is essential to efficient appends.\n        bytes32[] filledSubtrees;\n    }\n\n    // The number of inserted leaves\n    uint256 public nextLeafIndex = 0;\n\n    constructor(address _registryAddr) public {\n        tree.filledSubtrees = new bytes32[](DEPTH);\n        nameRegistry = Registry(_registryAddr);\n        merkleUtils = MTUtils(\n            nameRegistry.getContractDetails(ParamManager.MERKLE_UTILS())\n        );\n        setMerkleRootAndHeight(\n            merkleUtils.getZeroRoot(),\n            merkleUtils.getMaxTreeDepth()\n        );\n        bytes32 zero = merkleUtils.getRoot(0);\n        for (uint8 i = 1; i < DEPTH; i++) {\n            tree.filledSubtrees[i] = zero;\n        }\n    }\n\n    /**\n     * @notice Append leaf will append a leaf to the end of the tree\n     * @return The sibling nodes along the way.\n     */\n    function appendLeaf(bytes32 _leaf) public returns (uint256) {\n        uint256 currentIndex = nextLeafIndex;\n\n        uint256 depth = uint256(tree.height);\n        require(\n            currentIndex < uint256(2)**depth,\n            \"IncrementalMerkleTree: tree is full\"\n        );\n        bytes32 currentLevelHash = _leaf;\n        bytes32 left;\n        bytes32 right;\n        for (uint8 i = 0; i < tree.height; i++) {\n            if (currentIndex % 2 == 0) {\n                left = currentLevelHash;\n                right = merkleUtils.getRoot(i);\n                tree.filledSubtrees[i] = currentLevelHash;\n            } else {\n                left = tree.filledSubtrees[i];\n                right = currentLevelHash;\n            }\n            currentLevelHash = merkleUtils.getParent(left, right);\n            currentIndex >>= 1;\n        }\n        tree.root = currentLevelHash;\n        uint256 n;\n        n = nextLeafIndex;\n        nextLeafIndex += 1;\n        return n;\n    }\n\n    /**\n     * @notice Set the tree root and height of the stored tree\n     * @param _root The merkle root of the tree\n     * @param _height The height of the tree\n     */\n    function setMerkleRootAndHeight(bytes32 _root, uint256 _height) public {\n        tree.root = _root;\n        tree.height = _height;\n    }\n\n    function getTreeRoot() external view returns (bytes32) {\n        return tree.root;\n    }\n}\n"
    },
    "contracts/DepositManager.sol": {
      "content": "pragma solidity ^0.5.15;\npragma experimental ABIEncoderV2;\nimport {IncrementalTree} from \"./IncrementalTree.sol\";\nimport {Types} from \"./libs/Types.sol\";\nimport {Logger} from \"./Logger.sol\";\nimport {RollupUtils} from \"./libs/RollupUtils.sol\";\nimport {MerkleTreeUtils as MTUtils} from \"./MerkleTreeUtils.sol\";\nimport {NameRegistry as Registry} from \"./NameRegistry.sol\";\nimport {ITokenRegistry} from \"./interfaces/ITokenRegistry.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {Tree as MerkleTree} from \"./Tree.sol\";\nimport {ParamManager} from \"./libs/ParamManager.sol\";\n\n\ncontract DepositManager {\n    MTUtils public merkleUtils;\n    Registry public nameRegistry;\n    MerkleTree public balancesTree;\n    bytes32[] public pendingDeposits;\n    uint256 public queueNumber;\n    uint256 public depositSubtreeHeight;\n\n    address public Coordinator;\n\n    Logger public logger;\n    ITokenRegistry public tokenRegistry;\n    IERC20 public tokenContract;\n    IncrementalTree public accountsTree;\n\n    bool isPaused;\n\n    modifier isNotWaitingForFinalisation() {\n        assert(isPaused == false);\n        _;\n    }\n\n    constructor(address _registryAddr) public {\n        nameRegistry = Registry(_registryAddr);\n        merkleUtils = MTUtils(\n            nameRegistry.getContractDetails(ParamManager.MERKLE_UTILS())\n        );\n        tokenRegistry = ITokenRegistry(\n            nameRegistry.getContractDetails(ParamManager.TOKEN_REGISTRY())\n        );\n        logger = Logger(nameRegistry.getContractDetails(ParamManager.LOGGER()));\n        accountsTree = IncrementalTree(\n            nameRegistry.getContractDetails(ParamManager.ACCOUNTS_TREE())\n        );\n        balancesTree = MerkleTree(\n            nameRegistry.getContractDetails(ParamManager.BALANCES_TREE())\n        );\n    }\n\n    /**\n     * @notice Adds a deposit for the msg.sender to the deposit queue\n     * @param _amount Number of tokens that user wants to deposit\n     * @param _tokenType Type of token user is depositing\n     */\n    function deposit(uint256 _amount, uint256 _tokenType, bytes memory _pubkey)\n        public\n        isNotWaitingForFinalisation\n    {\n        depositFor(msg.sender, _amount, _tokenType, _pubkey);\n    }\n\n    /**\n     * @notice Adds a deposit for an address to the deposit queue\n     * @param _destination Address for which we are depositing\n     * @param _amount Number of tokens that user wants to deposit\n     * @param _tokenType Type of token user is depositing\n     */\n    function depositFor(\n        address _destination,\n        uint256 _amount,\n        uint256 _tokenType,\n        bytes memory _pubkey\n    ) public isNotWaitingForFinalisation {\n        // check amount is greater than 0\n        require(_amount > 0, \"token deposit must be greater than 0\");\n\n        // ensure public matches the destination address\n        require(\n            _destination == RollupUtils.calculateAddress(_pubkey),\n            \"public key and address don't match\"\n        );\n\n        // check token type exists\n        address tokenContractAddress = tokenRegistry.registeredTokens(\n            _tokenType\n        );\n        tokenContract = IERC20(tokenContractAddress);\n\n        // transfer from msg.sender to this contract\n        require(\n            tokenContract.transferFrom(msg.sender, address(this), _amount),\n            \"token transfer not approved\"\n        );\n\n        // Add pubkey to PDA tree\n        Types.PDALeaf memory newPDALeaf;\n        newPDALeaf.pubkey = _pubkey;\n\n        // returns leaf index upon successfull append\n        uint256 accID = accountsTree.appendLeaf(\n            RollupUtils.PDALeafToHash(newPDALeaf)\n        );\n\n        // create a new account\n        Types.UserAccount memory newAccount;\n        newAccount.balance = _amount;\n        newAccount.tokenType = _tokenType;\n        newAccount.nonce = 0;\n        newAccount.ID = accID;\n\n        // get new account hash\n        bytes32 accountHash = RollupUtils.HashFromAccount(newAccount);\n\n        // queue the deposit\n        pendingDeposits.push(accountHash);\n        // emit the event\n        logger.logDepositQueued(\n            accID,\n            _destination,\n            _amount,\n            _tokenType,\n            accountHash,\n            _pubkey\n        );\n\n        queueNumber++;\n        uint256 tmpDepositSubtreeHeight = 0;\n        uint256 tmp = queueNumber;\n        while (tmp % 2 == 0) {\n            bytes32[] memory deposits = new bytes32[](2);\n            deposits[0] = pendingDeposits[pendingDeposits.length - 2];\n            deposits[1] = pendingDeposits[pendingDeposits.length - 1];\n\n            pendingDeposits[pendingDeposits.length - 2] = merkleUtils.getParent(\n                deposits[0],\n                deposits[1]\n            );\n\n            // remove 1 deposit from the pending deposit queue\n            removeDeposit(pendingDeposits.length - 1);\n            tmp = tmp / 2;\n\n            // update the temp deposit subtree height\n            tmpDepositSubtreeHeight++;\n\n            // thow event for the coordinator\n            logger.logDepositLeafMerged(\n                deposits[0],\n                deposits[1],\n                pendingDeposits[0]\n            );\n        }\n        if (tmpDepositSubtreeHeight > depositSubtreeHeight) {\n            depositSubtreeHeight = tmpDepositSubtreeHeight;\n        }\n        if (depositSubtreeHeight == ParamManager.MAX_DEPOSIT_SUBTREE()) {\n            // pause and wait for finalisation\n            isPaused = true;\n        }\n    }\n\n    /**\n     * @notice Merges the deposit tree with the balance tree by\n     *        superimposing the deposit subtree on the balance tree\n     * @param _subTreeDepth Deposit tree depth or depth of subtree that is being deposited\n     * @param _zero_account_mp Merkle proof proving the node at which we are inserting the deposit subtree consists of all empty leaves\n     * @return Updates in-state merkle tree root\n     */\n    function finaliseDeposits(\n        uint256 _subTreeDepth,\n        Types.AccountMerkleProof memory _zero_account_mp\n    ) public returns (bytes32) {\n        bytes32 emptySubtreeRoot = merkleUtils.getRoot(_subTreeDepth);\n        // from mt proof we find the root of the tree\n        // we match the root to the balance tree root on-chain\n        require(\n            merkleUtils.verifyLeaf(\n                balancesTree.getRoot(),\n                emptySubtreeRoot,\n                _zero_account_mp.accountIP.pathToAccount,\n                _zero_account_mp.siblings\n            ),\n            \"proof invalid\"\n        );\n\n        // update the in-state balance tree with new leaf from pendingDeposits[0]\n        // balancesTree.updateLeaf(\n        //     pendingDeposits[0],\n        //     _zero_account_mp.accountIP.pathToAccount\n        // );\n\n        balancesTree.storeLeaf(\n            pendingDeposits[0],\n            _zero_account_mp.accountIP.pathToAccount,\n            _zero_account_mp.siblings\n        );\n        // empty the pending deposits queue\n        removeDeposit(0);\n        // update the number of elements present in the queue\n        queueNumber = queueNumber - 2**depositSubtreeHeight;\n        bytes32 newRoot = balancesTree.getRoot();\n\n        // emit the event\n        logger.logDepositFinalised(\n            pendingDeposits[0],\n            _zero_account_mp.accountIP.pathToAccount,\n            newRoot\n        );\n\n        // return the updated merkle tree root\n        return newRoot;\n    }\n\n    /**\n     * @notice Removes a deposit from the pendingDeposits queue and shifts the queue\n     * @param _index Index of the element to remove\n     * @return Remaining elements of the array\n     */\n    function removeDeposit(uint256 _index) internal {\n        require(\n            _index < pendingDeposits.length,\n            \"array index is out of bounds\"\n        );\n\n        // if we want to nuke the queue\n        if (_index == 0) {\n            for (uint256 i = 0; i < pendingDeposits.length - 1; i++) {\n                delete pendingDeposits[i];\n\n                pendingDeposits.length--;\n            }\n            return;\n        }\n\n        if (_index == pendingDeposits.length - 1) {\n            delete pendingDeposits[pendingDeposits.length - 1];\n            pendingDeposits.length--;\n            return;\n        }\n    }\n}\n"
    },
    "contracts/libs/Types.sol": {
      "content": "pragma solidity ^0.5.15;\n\n\n/**\n * @title DataTypes\n */\nlibrary Types {\n    // PDALeaf represents the leaf in\n    // Pubkey DataAvailability Tree\n    struct PDALeaf {\n        bytes pubkey;\n    }\n\n    // Batch represents the batch submitted periodically to the ethereum chain\n    struct Batch {\n        bytes32 stateRoot;\n        bytes32 accountRoot;\n        address committer;\n        bytes32 txRoot;\n        uint256 stakeCommitted;\n        uint256 finalisesOn;\n        uint256 timestamp;\n    }\n\n    // Transaction represents how each transaction looks like for\n    // this rollup chain\n    struct Transaction {\n        UserAccount from;\n        UserAccount to;\n        uint256 tokenType;\n        uint32 amount;\n        bytes signature;\n    }\n\n    // AccountInclusionProof consists of the following fields\n    // 1. Path to the account leaf from root in the balances tree\n    // 2. Actual data stored in the leaf\n    struct AccountInclusionProof {\n        uint256 pathToAccount;\n        UserAccount account;\n    }\n\n    struct TranasctionInclusionProof {\n        uint256 pathToTx;\n        Transaction data;\n    }\n\n    struct PDAInclusionProof {\n        uint256 pathToPubkey;\n        PDALeaf pubkey_leaf;\n    }\n\n    // UserAccount contains the actual data stored in the leaf of balance tree\n    struct UserAccount {\n        // ID is the path to the pubkey in the PDA tree\n        uint256 ID;\n        uint256 tokenType;\n        uint256 balance;\n        uint256 nonce;\n    }\n\n    struct AccountMerkleProof {\n        AccountInclusionProof accountIP;\n        bytes32[] siblings;\n    }\n\n    struct TransactionMerkleProof {\n        TranasctionInclusionProof _tx;\n        bytes32[] siblings;\n    }\n\n    struct PDAMerkleProof {\n        PDAInclusionProof _pda;\n        bytes32[] siblings;\n    }\n}\n"
    },
    "contracts/Logger.sol": {
      "content": "pragma solidity ^0.5.15;\n\n\ncontract Logger {\n    /*********************\n     * Rollup Contract *\n     ********************/\n    event NewBatch(\n        address committer,\n        bytes32 txroot,\n        bytes32 updatedRoot,\n        uint256 index\n    );\n\n    function logNewBatch(\n        address committer,\n        bytes32 txroot,\n        bytes32 updatedRoot,\n        uint256 index\n    ) public {\n        emit NewBatch(committer, txroot, updatedRoot, index);\n    }\n\n    event StakeWithdraw(address committed, uint256 amount, uint256 batch_id);\n\n    function logStakeWithdraw(\n        address committed,\n        uint256 amount,\n        uint256 batch_id\n    ) public {\n        emit StakeWithdraw(committed, amount, batch_id);\n    }\n\n    event BatchRollback(\n        uint256 batch_id,\n        address committer,\n        bytes32 stateRoot,\n        bytes32 txRoot,\n        uint256 stakeSlashed\n    );\n\n    function logBatchRollback(\n        uint256 batch_id,\n        address committer,\n        bytes32 stateRoot,\n        bytes32 txRoot,\n        uint256 stakeSlashed\n    ) public {\n        emit BatchRollback(\n            batch_id,\n            committer,\n            stateRoot,\n            txRoot,\n            stakeSlashed\n        );\n    }\n\n    event RollbackFinalisation(uint256 totalBatchesSlashed);\n\n    function logRollbackFinalisation(uint256 totalBatchesSlashed) public {\n        emit RollbackFinalisation(totalBatchesSlashed);\n    }\n\n    event RegisteredToken(uint256 tokenType, address tokenContract);\n\n    function logRegisteredToken(uint256 tokenType, address tokenContract)\n        public\n    {\n        emit RegisteredToken(tokenType, tokenContract);\n    }\n\n    event RegistrationRequest(address tokenContract);\n\n    function logRegistrationRequest(address tokenContract) public {\n        emit RegistrationRequest(tokenContract);\n    }\n\n    event DepositQueued(\n        uint256 AccountID,\n        address destination,\n        uint256 amount,\n        uint256 token,\n        bytes32 accountHash,\n        bytes pubkey\n    );\n\n    function logDepositQueued(\n        uint256 accountID,\n        address destination,\n        uint256 amount,\n        uint256 token,\n        bytes32 accountHash,\n        bytes memory pubkey\n    ) public {\n        emit DepositQueued(\n            accountID,\n            destination,\n            amount,\n            token,\n            accountHash,\n            pubkey\n        );\n    }\n\n    event DepositLeafMerged(bytes32 left, bytes32 right, bytes32 newRoot);\n\n    function logDepositLeafMerged(bytes32 left, bytes32 right, bytes32 newRoot)\n        public\n    {\n        emit DepositLeafMerged(left, right, newRoot);\n    }\n\n    event DepositsFinalised(\n        bytes32 depositSubTreeRoot,\n        uint256 pathToSubTree,\n        bytes32 newBalanceRoot\n    );\n\n    function logDepositFinalised(\n        bytes32 depositSubTreeRoot,\n        uint256 pathToSubTree,\n        bytes32 newBalanceRoot\n    ) public {\n        emit DepositsFinalised(\n            depositSubTreeRoot,\n            pathToSubTree,\n            newBalanceRoot\n        );\n    }\n}\n"
    },
    "contracts/libs/RollupUtils.sol": {
      "content": "pragma solidity ^0.5.15;\npragma experimental ABIEncoderV2;\n\nimport {Types} from \"./Types.sol\";\n\n\nlibrary RollupUtils {\n    // ---------- Account Related Utils -------------------\n    function PDALeafToHash(Types.PDALeaf memory _PDA_Leaf)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(_PDA_Leaf.pubkey));\n    }\n\n    // returns a new User Account with updated balance\n    function UpdateBalanceInAccount(\n        Types.UserAccount memory original_account,\n        uint256 new_balance\n    ) public pure returns (Types.UserAccount memory updated_account) {\n        original_account.balance = new_balance;\n        return original_account;\n    }\n\n    function BalanceFromAccount(Types.UserAccount memory account)\n        public\n        pure\n        returns (uint256)\n    {\n        return account.balance;\n    }\n\n    function HashFromAccount(Types.UserAccount memory account)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(BytesFromAccount(account));\n    }\n\n    function BytesFromAccount(Types.UserAccount memory account)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encode(\n                account.ID,\n                account.balance,\n                account.nonce,\n                account.tokenType\n            );\n    }\n\n    // ---------- Tx Related Utils -------------------\n\n    function BytesFromTx(Types.Transaction memory _tx)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(_tx);\n    }\n\n    function HashFromTx(Types.Transaction memory _tx)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(BytesFromTx(_tx));\n    }\n\n    /**\n     * @notice Calculates the address from the pubkey\n     * @param pub is the pubkey\n     * @return Returns the address that has been calculated from the pubkey\n     */\n    function calculateAddress(bytes memory pub)\n        public\n        pure\n        returns (address addr)\n    {\n        bytes32 hash = keccak256(pub);\n        assembly {\n            mstore(0, hash)\n            addr := mload(0)\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ITokenRegistry.sol": {
      "content": "pragma solidity ^0.5.15;\n\n\n// token registry contract interface\ncontract ITokenRegistry {\n    address public Coordinator;\n    uint256 public numTokens;\n    mapping(address => bool) public pendingRegistrations;\n    mapping(uint256 => address) public registeredTokens;\n\n    modifier onlyCoordinator() {\n        assert(msg.sender == Coordinator);\n        _;\n    }\n\n    function requestTokenRegistration(address tokenContract) public {}\n\n    function finaliseTokenRegistration(address tokenContract) public {}\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity ^0.5.15;\n\n\n// ERC20 token interface\ncontract IERC20 {\n    function transferFrom(address from, address to, uint256 value)\n        public\n        returns (bool)\n    {}\n\n    function transfer(address recipient, uint256 value) public returns (bool) {}\n}\n"
    },
    "contracts/TestToken.sol": {
      "content": "pragma solidity ^0.5.15;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\n\n\n/**\n * @title TestToken is a basic ERC20 Token\n */\ncontract TestToken is ERC20, Ownable {\n    /**\n     * @dev assign totalSupply to account creating this contract */\n    constructor() public {\n        _mint(msg.sender, 100000000000);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/Rollup.sol": {
      "content": "pragma solidity ^0.5.15;\npragma experimental ABIEncoderV2;\n\nimport {Logger} from \"./logger.sol\";\nimport {Tree as MerkleTree} from \"./Tree.sol\";\nimport {IncrementalTree} from \"./IncrementalTree.sol\";\nimport {ParamManager} from \"./libs/ParamManager.sol\";\nimport {RollupUtils} from \"./libs/RollupUtils.sol\";\nimport {Types} from \"./libs/Types.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {ITokenRegistry} from \"./interfaces/ITokenRegistry.sol\";\nimport {NameRegistry as Registry} from \"./NameRegistry.sol\";\nimport {MerkleTreeUtils as MTUtils} from \"./MerkleTreeUtils.sol\";\nimport {ECVerify} from \"./libs/ECVerify.sol\";\n\n\n// Main rollup contract\ncontract Rollup {\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n    using ECVerify for bytes32;\n\n    /*********************\n     * Variable Declarations *\n     ********************/\n\n    address coordinator;\n\n    // External contracts\n    MerkleTree public balancesTree;\n    IncrementalTree public accountsTree;\n    Logger public logger;\n    ITokenRegistry public tokenRegistry;\n    IERC20 public tokenContract;\n    Registry public nameRegistry;\n    Types.Batch[] public batches;\n    MTUtils public merkleUtils;\n\n    // this variable will be greater than 0 if\n    // there is rollback in progress\n    // will be reset to 0 once rollback is completed\n    uint256 invalidBatchMarker;\n\n    modifier onlyCoordinator() {\n        assert(msg.sender == coordinator);\n        _;\n    }\n\n    modifier isNotRollingBack() {\n        assert(invalidBatchMarker == 0);\n        _;\n    }\n\n    modifier isRollingBack() {\n        assert(invalidBatchMarker > 0);\n        _;\n    }\n\n    // Stores transaction paths claimed per batch\n    // TO BE REMOVED post withdraw mass migration\n    bool[][] withdrawTxClaimed = new bool[][](ParamManager.MAX_TXS_PER_BATCH());\n\n    /*********************\n     * Constructor *\n     ********************/\n    constructor(address _registryAddr) public {\n        nameRegistry = Registry(_registryAddr);\n\n        logger = Logger(nameRegistry.getContractDetails(ParamManager.LOGGER()));\n        balancesTree = MerkleTree(\n            nameRegistry.getContractDetails(ParamManager.BALANCES_TREE())\n        );\n        merkleUtils = MTUtils(\n            nameRegistry.getContractDetails(ParamManager.MERKLE_UTILS())\n        );\n        accountsTree = IncrementalTree(\n            nameRegistry.getContractDetails(ParamManager.ACCOUNTS_TREE())\n        );\n        tokenContract = IERC20(\n            nameRegistry.getContractDetails(ParamManager.TEST_TOKEN())\n        );\n\n        tokenRegistry = ITokenRegistry(\n            nameRegistry.getContractDetails(ParamManager.TOKEN_REGISTRY())\n        );\n    }\n\n    /**\n     * @notice Submits a new batch to batches\n     * @param _txs Compressed transactions .\n     * @param _updatedRoot New balance tree root after processing all the transactions\n     */\n    function submitBatch(bytes[] calldata _txs, bytes32 _updatedRoot)\n        external\n        payable\n        onlyCoordinator\n        isNotRollingBack\n    {\n        require(\n            msg.value == ParamManager.STAKE_AMOUNT(),\n            \"Please send 32 eth with batch as stake\"\n        );\n        if (_txs.length > ParamManager.MAX_TXS_PER_BATCH()) {\n            // TODO\n        }\n\n        require(\n            _txs.length <= ParamManager.MAX_TXS_PER_BATCH(),\n            \"Batch contains more transations than the limit\"\n        );\n        bytes32 txRoot = merkleUtils.getMerkleRoot(_txs);\n\n        // TODO need to commit the depths of all trees as well, because they are variable depth\n        // make merkel root of all txs\n        Types.Batch memory newBatch = Types.Batch({\n            stateRoot: _updatedRoot,\n            accountRoot: accountsTree.getTreeRoot(),\n            committer: msg.sender,\n            txRoot: txRoot,\n            stakeCommitted: msg.value,\n            finalisesOn: block.number + ParamManager.TIME_TO_FINALISE(),\n            timestamp: now\n        });\n\n        batches.push(newBatch);\n        logger.logNewBatch(\n            newBatch.committer,\n            txRoot,\n            _updatedRoot,\n            batches.length - 1\n        );\n    }\n\n    /**\n     *  disputeBatch processes a transactions and returns the updated balance tree\n     *  and the updated leaves.\n     * @notice Gives the number of batches submitted on-chain\n     * @return Total number of batches submitted onchain\n     */\n    function disputeBatch(\n        uint256 _batch_id,\n        Types.Transaction[] memory _txs,\n        Types.AccountMerkleProof[] memory _from_proofs,\n        Types.PDAMerkleProof[] memory _pda_proof,\n        Types.AccountMerkleProof[] memory _to_proofs\n    ) public {\n        // load batch\n        // Types.Batch memory disputed_batch = batches[_batch_id];\n        require(\n            batches[_batch_id].stakeCommitted != 0,\n            \"Batch doesnt exist or is slashed already\"\n        );\n\n        // check if batch is disputable\n        require(\n            block.number < batches[_batch_id].finalisesOn,\n            \"Batch already finalised\"\n        );\n\n        require(\n            _batch_id < invalidBatchMarker,\n            \"Already successfully disputed. Roll back in process\"\n        );\n\n        // generate merkle tree from the txs provided by user\n        bytes[] memory txs;\n        for (uint256 i = 0; i < _txs.length; i++) {\n            txs[i] = RollupUtils.BytesFromTx(_txs[i]);\n        }\n        bytes32 txRoot = merkleUtils.getMerkleRoot(txs);\n\n        // if tx root while submission doesnt match tx root of given txs\n        // dispute is unsuccessful\n        require(\n            txRoot != batches[_batch_id].txRoot,\n            \"Invalid dispute, tx root doesn't match\"\n        );\n\n        // run every transaction through transaction evaluators\n        bytes32 newBalanceRoot;\n        uint256 fromBalance;\n        uint256 toBalance;\n        bool isTxValid;\n\n        // start with false state\n        bool isDisputeValid = false;\n\n        for (uint256 i = 0; i < _txs.length; i++) {\n            // call process tx update for every transaction to check if any\n            // tx evaluates correctly\n            (newBalanceRoot, fromBalance, toBalance, isTxValid) = processTx(\n                batches[_batch_id].stateRoot,\n                batches[_batch_id].accountRoot,\n                _txs[i],\n                _pda_proof[i],\n                _from_proofs[i],\n                _to_proofs[i]\n            );\n            if (!isTxValid) {\n                isDisputeValid = true;\n                break;\n            }\n        }\n\n        // dispute is valid, we need to slash and rollback :(\n        if (isDisputeValid) {\n            // before rolling back mark the batch invalid\n            // so we can pause and unpause\n            invalidBatchMarker = _batch_id;\n            SlashAndRollback();\n            return;\n        }\n\n        // if new root doesnt match what was submitted by coordinator\n        // slash and rollback\n        if (newBalanceRoot != batches[_batch_id].stateRoot) {\n            invalidBatchMarker = _batch_id;\n            SlashAndRollback();\n            return;\n        }\n    }\n\n    /**\n     * @notice processTx processes a transactions and returns the updated balance tree\n     *  and the updated leaves\n     * conditions in require mean that the dispute be declared invalid\n     * if conditons evaluate if the coordinator was at fault\n     * @return Total number of batches submitted onchain\n     */\n    function processTx(\n        bytes32 _balanceRoot,\n        bytes32 _accountsRoot,\n        Types.Transaction memory _tx,\n        Types.PDAMerkleProof memory _pda_proof,\n        Types.AccountMerkleProof memory _from_merkle_proof,\n        Types.AccountMerkleProof memory _to_merkle_proof\n    ) public returns (bytes32, uint256, uint256, bool) {\n        // verify pubkey exists in PDA tree\n        require(\n            merkleUtils.verify(\n                _accountsRoot,\n                _pda_proof._pda.pubkey_leaf.pubkey,\n                _pda_proof._pda.pathToPubkey,\n                _pda_proof.siblings\n            ),\n            \"The PDA proof is incorrect\"\n        );\n\n        // convert pubkey path to ID\n        uint256 computedID = merkleUtils.pathToIndex(\n            _pda_proof._pda.pathToPubkey,\n            ParamManager.MAX_DEPTH()\n        );\n\n        require(\n            computedID == _tx.from.ID,\n            \"Pubkey not related to the from account in the transaction\"\n        );\n\n        require(\n            RollupUtils.calculateAddress(_pda_proof._pda.pubkey_leaf.pubkey) ==\n                RollupUtils.HashFromTx(_tx).ecrecovery(_tx.signature),\n            \"Signature is incorrect\"\n        );\n\n        // check token type is registered\n        if (tokenRegistry.registeredTokens(_tx.tokenType) == address(0)) {\n            // invalid state transition\n            // to be slashed because the submitted transaction\n            // had invalid token type\n            return (ParamManager.ZERO_BYTES32(), 0, 0, false);\n        }\n\n        // verify from leaf exists in the balance tree\n        require(\n            merkleUtils.verify(\n                _balanceRoot,\n                RollupUtils.BytesFromAccount(_tx.from),\n                _from_merkle_proof.accountIP.pathToAccount,\n                _from_merkle_proof.siblings\n            ),\n            \"Merkle Proof for from leaf is incorrect\"\n        );\n\n        if (_tx.amount < 0) {\n            // invalid state transition\n            // needs to be slashed because the submitted transaction\n            // had amount less than 0\n            return (ParamManager.ZERO_BYTES32(), 0, 0, false);\n        }\n\n        // check from leaf has enough balance\n        if (_from_merkle_proof.accountIP.account.balance < _tx.amount) {\n            // invalid state transition\n            // needs to be slashed because the account doesnt have enough balance\n            // for the transfer\n            return (ParamManager.ZERO_BYTES32(), 0, 0, false);\n        }\n\n        // account holds the token type in the tx\n        if (_from_merkle_proof.accountIP.account.tokenType != _tx.tokenType) {\n            // invalid state transition\n            // needs to be slashed because the submitted transaction\n            // had invalid token type\n            return (ParamManager.ZERO_BYTES32(), 0, 0, false);\n        }\n\n        // reduce balance of from leaf\n        Types.UserAccount memory new_from_leaf = RollupUtils\n            .UpdateBalanceInAccount(\n            _from_merkle_proof.accountIP.account,\n            RollupUtils\n                .BalanceFromAccount(_from_merkle_proof.accountIP.account)\n                .sub(_tx.amount)\n        );\n\n        bytes32 newRoot = merkleUtils.updateLeafWithSiblings(\n            keccak256(RollupUtils.BytesFromAccount(new_from_leaf)),\n            _from_merkle_proof.accountIP.pathToAccount,\n            _from_merkle_proof.siblings\n        );\n\n        // verify to leaf exists in the balance tree\n        require(\n            merkleUtils.verify(\n                newRoot,\n                RollupUtils.BytesFromAccount(_tx.to),\n                _to_merkle_proof.accountIP.pathToAccount,\n                _to_merkle_proof.siblings\n            ),\n            \"Merkle Proof for from leaf is incorrect\"\n        );\n\n        // account holds the token type in the tx\n        if (_to_merkle_proof.accountIP.account.tokenType != _tx.tokenType) {\n            // invalid state transition\n            // needs to be slashed because the submitted transaction\n            // had invalid token type\n            return (ParamManager.ZERO_BYTES32(), 0, 0, false);\n        }\n\n        // increase balance of to leaf\n        Types.UserAccount memory new_to_leaf = RollupUtils\n            .UpdateBalanceInAccount(\n            _to_merkle_proof.accountIP.account,\n            RollupUtils\n                .BalanceFromAccount(_to_merkle_proof.accountIP.account)\n                .add(_tx.amount)\n        );\n\n        // update the merkle tree\n        balancesTree.update(\n            RollupUtils.BytesFromAccount(new_to_leaf),\n            _to_merkle_proof.accountIP.pathToAccount\n        );\n        newRoot = merkleUtils.updateLeafWithSiblings(\n            keccak256(RollupUtils.BytesFromAccount(new_to_leaf)),\n            _to_merkle_proof.accountIP.pathToAccount,\n            _to_merkle_proof.siblings\n        );\n\n        return (\n            newRoot,\n            RollupUtils.BalanceFromAccount(new_from_leaf),\n            RollupUtils.BalanceFromAccount(new_to_leaf),\n            true\n        );\n    }\n\n    /**\n     * @notice SlashAndRollback slashes all the coordinator's who have built on top of the invalid batch\n     * and rewards challegers. Also deletes all the batches after invalid batch\n     */\n    function SlashAndRollback() public isRollingBack {\n        uint256 challengerRewards = 0;\n        uint256 burnedAmount = 0;\n        uint256 totalSlashings = 0;\n\n        for (uint256 i = batches.length - 1; i >= invalidBatchMarker; i--) {\n            // if gas left is low we would like to do all the transfers\n            // and persist intermediate states so someone else can send another tx\n            // and rollback remaining batches\n            if (gasleft() <= ParamManager.MIN_GAS_LIMIT_LEFT()) {\n                // exit loop gracefully\n                break;\n            }\n\n            if (i == invalidBatchMarker) {\n                // we have completed rollback\n                // update the marker\n                invalidBatchMarker = 0;\n            }\n\n            // load batch\n            Types.Batch memory batch = batches[i];\n\n            // TODO use safe math\n            // calculate challeger's reward\n            challengerRewards += (batch.stakeCommitted * 2) / 3;\n            burnedAmount += batch.stakeCommitted.sub(challengerRewards);\n\n            batches[i].stakeCommitted = 0;\n\n            // delete batch\n            delete batches[i];\n\n            totalSlashings++;\n            logger.logBatchRollback(\n                i,\n                batch.committer,\n                batch.stateRoot,\n                batch.txRoot,\n                batch.stakeCommitted\n            );\n        }\n\n        // TODO add deposit rollback\n\n        // transfer reward to challenger\n        (msg.sender).transfer(challengerRewards);\n\n        // burn the remaning amount\n        address payable burnAddress = ParamManager.BURN_ADDRESS();\n        (burnAddress).transfer(burnedAmount);\n\n        // resize batches length\n        batches.length = batches.length.sub(invalidBatchMarker.sub(1));\n\n        logger.logRollbackFinalisation(totalSlashings);\n    }\n\n    /**\n     * @notice Withdraw delay allows coordinators to withdraw their stake after the batch has been finalised\n     * @param batch_id Batch ID that the coordinator submitted\n     */\n    function WithdrawStake(uint256 batch_id) public {\n        Types.Batch memory committedBatch = batches[batch_id];\n        require(\n            msg.sender == committedBatch.committer,\n            \"You are not the correct committer for this batch\"\n        );\n        require(\n            block.number > committedBatch.finalisesOn,\n            \"This batch is not yet finalised, check back soon!\"\n        );\n        msg.sender.transfer(committedBatch.stakeCommitted);\n        logger.logStakeWithdraw(\n            msg.sender,\n            committedBatch.stakeCommitted,\n            batch_id\n        );\n    }\n\n    /**\n     * @notice Allows user to withdraw the balance in the leaf of the balances tree.\n     *        User has to do the following: Prove that a transfer of X tokens was made to the burn address or leaf 0\n     *        The batch we are allowing withdraws from should have been already finalised, so we can assume all data in the batch to be correct\n     * @param _batch_id Deposit tree depth or depth of subtree that is being deposited\n     * @param withdraw_tx_proof contains the siblints, txPath and the txData for the withdraw transaction\n     */\n    // function Withdraw(\n    //     uint256 _batch_id,\n    //     Types.PDAMerkleProof memory _pda_proof,\n    //     Types.TransactionMerkleProof memory withdraw_tx_proof\n    // ) public {\n    //     // make sure the batch id is valid\n    //     require(\n    //         batches.length - 1 >= _batch_id,\n    //         \"Batch id greater than total number of batches, invalid batch id\"\n    //     );\n\n    //     Types.Batch memory batch = batches[_batch_id];\n\n    //     // check if the batch is finalised\n    //     require(block.number > batch.finalisesOn, \"Batch not finalised yt\");\n    //     // verify transaction exists in the batch\n    //     merkleUtils.verify(\n    //         batch.txRoot,\n    //         RollupUtils.BytesFromTx(withdraw_tx_proof._tx.data),\n    //         withdraw_tx_proof._tx.pathToTx,\n    //         withdraw_tx_proof.siblings\n    //     );\n\n    //     // check if the transaction is withdraw transaction\n    //     // ensure the `to` leaf was the 0th leaf\n    //     require(\n    //         withdraw_tx_proof._tx.data.to.ID == 0,\n    //         \"Not a withdraw transaction\"\n    //     );\n\n    //     bool isClaimed = withdrawTxClaimed[_batch_id][withdraw_tx_proof\n    //         ._tx\n    //         .pathToTx];\n    //     require(!isClaimed, \"Withdraw transaction already claimed\");\n    //     withdrawTxClaimed[_batch_id][withdraw_tx_proof._tx.pathToTx] = true;\n\n    //     // withdraw checks out, transfer to the account in account tree\n    //     address tokenContractAddress = tokenRegistry.registeredTokens(\n    //         withdraw_tx_proof._tx.data.tokenType\n    //     );\n\n    //     // convert pubkey path to ID\n    //     // TODO replace MAX_DEPTH with the committed depth\n    //     uint256 computedID = merkleUtils.pathToIndex(\n    //         _pda_proof._pda.pathToPubkey,\n    //         ParamManager.MAX_DEPTH()\n    //     );\n\n    //     require(\n    //         computedID == withdraw_tx_proof._tx.data.from.ID,\n    //         \"Pubkey not related to the from account in the transaction\"\n    //     );\n\n    //     address receiver = RollupUtils.calculateAddress(\n    //         _pda_proof._pda.pubkey_leaf.pubkey\n    //     );\n    //     require(\n    //         receiver ==\n    //             RollupUtils.HashFromTx(withdraw_tx_proof._tx.data).ecrecovery(\n    //                 withdraw_tx_proof._tx.data.signature\n    //             ),\n    //         \"Signature is incorrect\"\n    //     );\n\n    //     uint256 amount = withdraw_tx_proof._tx.data.amount;\n\n    //     tokenContract = IERC20(tokenContractAddress);\n    //     require(tokenContract.transfer(receiver, amount), \"Unable to trasnfer\");\n    // }\n}\n"
    },
    "contracts/logger.sol": {
      "content": "pragma solidity ^0.5.15;\n\n\ncontract Logger {\n    /*********************\n     * Rollup Contract *\n     ********************/\n    event NewBatch(\n        address committer,\n        bytes32 txroot,\n        bytes32 updatedRoot,\n        uint256 index\n    );\n\n    function logNewBatch(\n        address committer,\n        bytes32 txroot,\n        bytes32 updatedRoot,\n        uint256 index\n    ) public {\n        emit NewBatch(committer, txroot, updatedRoot, index);\n    }\n\n    event StakeWithdraw(address committed, uint256 amount, uint256 batch_id);\n\n    function logStakeWithdraw(\n        address committed,\n        uint256 amount,\n        uint256 batch_id\n    ) public {\n        emit StakeWithdraw(committed, amount, batch_id);\n    }\n\n    event BatchRollback(\n        uint256 batch_id,\n        address committer,\n        bytes32 stateRoot,\n        bytes32 txRoot,\n        uint256 stakeSlashed\n    );\n\n    function logBatchRollback(\n        uint256 batch_id,\n        address committer,\n        bytes32 stateRoot,\n        bytes32 txRoot,\n        uint256 stakeSlashed\n    ) public {\n        emit BatchRollback(\n            batch_id,\n            committer,\n            stateRoot,\n            txRoot,\n            stakeSlashed\n        );\n    }\n\n    event RollbackFinalisation(uint256 totalBatchesSlashed);\n\n    function logRollbackFinalisation(uint256 totalBatchesSlashed) public {\n        emit RollbackFinalisation(totalBatchesSlashed);\n    }\n\n    event RegisteredToken(uint256 tokenType, address tokenContract);\n\n    function logRegisteredToken(uint256 tokenType, address tokenContract)\n        public\n    {\n        emit RegisteredToken(tokenType, tokenContract);\n    }\n\n    event RegistrationRequest(address tokenContract);\n\n    function logRegistrationRequest(address tokenContract) public {\n        emit RegistrationRequest(tokenContract);\n    }\n\n    event DepositQueued(\n        uint256 AccountID,\n        address destination,\n        uint256 amount,\n        uint256 token,\n        bytes32 accountHash,\n        bytes pubkey\n    );\n\n    function logDepositQueued(\n        uint256 accountID,\n        address destination,\n        uint256 amount,\n        uint256 token,\n        bytes32 accountHash,\n        bytes memory pubkey\n    ) public {\n        emit DepositQueued(\n            accountID,\n            destination,\n            amount,\n            token,\n            accountHash,\n            pubkey\n        );\n    }\n\n    event DepositLeafMerged(bytes32 left, bytes32 right, bytes32 newRoot);\n\n    function logDepositLeafMerged(bytes32 left, bytes32 right, bytes32 newRoot)\n        public\n    {\n        emit DepositLeafMerged(left, right, newRoot);\n    }\n\n    event DepositsFinalised(\n        bytes32 depositSubTreeRoot,\n        uint256 pathToSubTree,\n        bytes32 newBalanceRoot\n    );\n\n    function logDepositFinalised(\n        bytes32 depositSubTreeRoot,\n        uint256 pathToSubTree,\n        bytes32 newBalanceRoot\n    ) public {\n        emit DepositsFinalised(\n            depositSubTreeRoot,\n            pathToSubTree,\n            newBalanceRoot\n        );\n    }\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity ^0.5.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add \n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n                \n                for { \n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint _start,\n        uint _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_bytes.length >= (_start + _length));\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        require(_bytes.length >= (_start + 20));\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n        require(_bytes.length >= (_start + 1));\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\n        require(_bytes.length >= (_start + 2));\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\n        require(_bytes.length >= (_start + 4));\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\n        require(_bytes.length >= (_start + 8));\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\n        require(_bytes.length >= (_start + 12));\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\n        require(_bytes.length >= (_start + 16));\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        require(_bytes.length >= (_start + 32));\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32));\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts/libs/ECVerify.sol": {
      "content": "pragma solidity ^0.5.15;\n\n\nlibrary ECVerify {\n    function ecrecovery(bytes32 hash, bytes memory sig)\n        public\n        pure\n        returns (address)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (sig.length != 65) {\n            return address(0x0);\n        }\n\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := and(mload(add(sig, 65)), 255)\n        }\n\n        // https://github.com/ethereum/go-ethereum/issues/2053\n        if (v < 27) {\n            v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0x0);\n        }\n\n        // get address out of hash and signature\n        address result = ecrecover(hash, v, r, s);\n\n        // ecrecover returns zero on error\n        require(result != address(0x0));\n\n        return result;\n    }\n\n    function ecrecovery(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        public\n        pure\n        returns (address)\n    {\n        // get address out of hash and signature\n        address result = ecrecover(hash, v, r, s);\n\n        // ecrecover returns zero on error\n        require(result != address(0x0));\n\n        return result;\n    }\n\n    function ecverify(bytes32 hash, bytes memory sig, address signer)\n        public\n        pure\n        returns (bool)\n    {\n        return signer == ecrecovery(hash, sig);\n    }\n}\n"
    },
    "contracts/TokenRegistry.sol": {
      "content": "pragma solidity >=0.4.21;\n\nimport {Logger} from \"./Logger.sol\";\nimport {NameRegistry as Registry} from \"./NameRegistry.sol\";\nimport {ParamManager} from \"./libs/ParamManager.sol\";\n\n\ncontract TokenRegistry {\n    address public Coordinator;\n    address public rollupNC;\n    Logger public logger;\n    mapping(address => bool) public pendingRegistrations;\n    mapping(uint256 => address) public registeredTokens;\n\n    uint256 public numTokens;\n\n    modifier onlyCoordinator() {\n        assert(msg.sender == Coordinator);\n        _;\n    }\n    Registry public nameRegistry;\n\n    constructor(address _registryAddr) public {\n        nameRegistry = Registry(_registryAddr);\n        Coordinator = msg.sender;\n\n        logger = Logger(nameRegistry.getContractDetails(ParamManager.LOGGER()));\n    }\n\n    /**\n     * @notice Requests addition of a new token to the chain, can be called by anyone\n     * @param tokenContract Address for the new token being added\n     */\n    function requestTokenRegistration(address tokenContract) public {\n        require(\n            pendingRegistrations[tokenContract] == false,\n            \"Token already registered.\"\n        );\n        pendingRegistrations[tokenContract] = true;\n        logger.logRegistrationRequest(tokenContract);\n    }\n\n    /**\n     * @notice Add new tokens to the rollup chain by assigning them an ID called tokenType from here on\n     * @param tokenContract Deposit tree depth or depth of subtree that is being deposited\n     * TODO: add a modifier to allow only coordinator\n     */\n    function finaliseTokenRegistration(address tokenContract) public {\n        require(\n            pendingRegistrations[tokenContract],\n            \"Token was not registered\"\n        );\n        numTokens++;\n        registeredTokens[numTokens] = tokenContract; // tokenType => token contract address\n        logger.logRegisteredToken(numTokens, tokenContract);\n    }\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity >=0.4.21 <0.6.0;\n\n\ncontract Migrations {\n    address public owner;\n    uint256 public last_completed_migration;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    function setCompleted(uint256 completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n"
    },
    "contracts/POB.sol": {
      "content": "pragma solidity ^0.5.15;\n\n\n/*\nPOB contract handles all the proof of burn related functionality\n*/\ncontract POB {\n    constructor() public {}\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}